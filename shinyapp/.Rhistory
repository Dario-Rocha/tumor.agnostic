a.exp<- expresion_gide_counts
a.tar<- clinical_data_gide_final[colnames(expresion_gide_counts),]
a.anot<- data.frame("symbol"= rownames(expresion_gide_counts), stringsAsFactors = FALSE)
a.entrez<- mapIds(org.Hs.eg.db, keys=a.anot$symbol, column="ENTREZID", keytype="SYMBOL", multiVals="first")
class(a.entrez)
a.anot$entrezid<- a.entrez
#elist
a.elists$gide<- new("EList", list(E=a.exp,
targets= a.tar,
genes= a.anot))
#sacar on
a.elists$gide<- a.elists$gide[,a.elists$gide$targets$`RNA Sequencing`=="PRE"]
#sacar mising entrez
a.elists$gide<- a.elists$gide[!is.na(a.elists$gide$genes$entrezid),]
#normalizar
colSums(a.elists$gide$E[,1:20]) #ver si no son TPM
a.elists$gide<- NormalizeRNAseq(elist.object = a.elists$gide, method = "TMM", calc.log = TRUE)
#avereps
sum(duplicated(a.elists$gide$genes$entrezid))
#variables
a.elists$gide$targets$barcode<- colnames(a.elists$gide$E)
table(a.elists$gide$targets$Response, useNA="ifany")
a.elists$gide$targets$response<- recode(a.elists$gide$targets$Response,
"Non responder"= "nonresponse",
"Responder"= "response")
#a.hugo----
a.names
dim(hugo_expresion_FPKM)
View(hugo_expresion_FPKM[1:10,])
dim(clinical_data_hugo)
View(clinical_data_hugo)
a.common<- intersect(colnames(hugo_expresion_FPKM), rownames(clinical_data_hugo))
a.exp<- hugo_expresion_FPKM[,a.common]
a.tar<- clinical_data_hugo[a.common,]
a.annot<- data.frame("symbol"= rownames(a.exp), stringsAsFactors = FALSE)
a.entrez<- mapIds(org.Hs.eg.db, keys=a.annot$symbol, column="ENTREZID", keytype="SYMBOL", multiVals="first")
class(a.entrez)
a.annot$entrezid<- a.entrez
#elist
a.elists$hugo<- new("EList", list(E=a.exp,
targets= a.tar,
genes= a.annot))
#sacar missing entrez
sum(is.na(a.annot$entrezid))
a.elists$hugo<- a.elists$hugo[!is.na(a.elists$hugo$genes$entrezid),]
#normalizar
boxplot(log(a.elists$hugo$E+0.5)) #está joya
a.elists$hugo$E<- log(a.elists$hugo$E+0.5)
#avereps
sum(duplicated(a.elists$hugo$genes$entrezid)) #no hace falta
#targets
a.elists$hugo$targets$barcode<- rownames(a.elists$hugo$targets)
table(a.elists$hugo$targets$Respuesta, useNA="ifany")
a.elists$hugo$targets$response<- recode(a.elists$hugo$targets$Respuesta,
"Non responder"= "nonresponse",
"Responder"= "response")
#pasar expresión a matrix
a.elists$hugo$E<- as.matrix(a.elists$hugo$E)
View(a.elists$hugo$E[1:10,])
#a.check----
sapply(a.elists, function(one.elist){
names(one.elist$genes)
})
sapply(a.elists, function(one.elist){
c("barcode", "response") %in% colnames(one.elist$targets)
})
sapply(a.elists, dim)
#rownames
a.elists<- lapply(a.elists, function(one.elist){
rownames(one.elist$E)<- one.elist$genes$entrezid
rownames(one.elist$genes)<- one.elist$genes$entrezid
return(one.elist)
})
sapply(a.elists, function(one.elist){
rownames(one.elist)[1:5]
})
sapply(a.elists, function(one.elist){
class(one.elist$E)
})
#B)PBCMC----
#normbres para pbcmc
a.elists<- lapply(a.elists, function(one.elist){
one.elist$genes$NCBI.gene.symbol<- one.elist$genes$symbol
one.elist$genes$EntrezGene.ID<- one.elist$genes$entrezid
one.elist$genes$probe<- one.elist$genes$entrezid
return(one.elist)
})
#clasificar
a.classes<- lapply(a.elists, function(one.elist){
pam50object<- PAM50(exprs = one.elist$E, annotation = one.elist$genes)
filtratedobject<- filtrate(pam50object)
classifiedobject<- classify(filtratedobject, std = "median")
permutatedobject<- permutate(classifiedobject, nPerm=10000, pCutoff=0.01, where="fdr",
corCutoff=0.1, keep=FALSE, verbose=TRUE,
BPPARAM=bpparam())
final.class<- ReducePbcmc(permutatedobject) #es una función que armé en usefulfunctinos.r
final.class$class<- recode(final.class$pam50.pbcmc,
"Basal"= "C2",
"Her2"= "C2",
"LumB"= "C2",
"LumA"= "C1")
return(final.class)
})
#agregar
b.elists<- MergeTargetsList(listaomicos = a.elists, listanuevos = a.classes)
library(plyr)
#agregar
b.elists<- MergeTargetsList(listaomicos = a.elists, listanuevos = a.classes)
#agregar
b.elists<- MergeTargetsList(listaomicos = a.elists, listanuevos = a.classes, id.var = "barcode")
sapply(a.elists, function(one.elist){
c("barcode", "response") %in% colnames(one.elist$targets)
})
#agregar barcode
b.classes<- lapply(a.classes, function(one.data){
colnames(one.data)[1]<- "barcode"
return(one.data)
})
#agregar
b.elists<- MergeTargetsList(listaomicos = a.elists, listanuevos = b.classes, id.var = "barcode")
#ver
sapply(b.eslits, function(one.elist){
table(one.elist$targets$class, useNA="ifany")
})
#ver
sapply(b.elists, function(one.elist){
table(one.elist$targets$class, useNA="ifany")
})
#guardar como rds
saveRDS(b.elists, "ICB_data_7.0.RDS")
#C)TEST----
#quitar noa y normales
c.elists<- lapply(b.elists, function(one.elist){
one.elist<- one.elist[,which(one.elist$targets$class %in% c("C1", "C2"))]
return(one.elist)
})
#fisher comparando response/nonresponse
fisher.test(c.elists$allen$targets$response ~ c.elists$allen$targets$class)
#fisher comparando response/nonresponse
fisher.test(c.elists$allen$targets$response, c.elists$allen$targets$class)
#fisher comparando response/nonresponse
z<-fisher.test(c.elists$allen$targets$response, c.elists$allen$targets$class)
z$p.value
#fisher comparando response/nonresponse
c.fishers<- sapply(c.elists, function(one.elist){
fisher.test(one.elist$targets$response, one.elist$targets$class)$p.value
})
c.fishers
lapply(c.elists, function(one.elist){
table(one.elist$targets$response, one.elist$targets$class)
})
c.fishers
library(nonnest2)
require("survival")
pbc  <- subset(pbc, !is.na(trt))
table(pbc$status)
mod1 <- coxph(Surv(time, status==2) ~ age, data=pbc, x=T)
mod2 <- coxph(Surv(time, status==2) ~ age + albumin + bili + edema + protime, data=pbc,  x=T)
mod3 <- coxph(Surv(time, status==2) ~ age + log(albumin) + log(bili) + edema + log(protime), data=pbc, x=T)
mod4<-  coxph(Surv(time, status==2) ~ albumin, data=pbc, x=T)
plrtest(mod3, mod2, nested=F) # non-nested models
library(nonnest2)
plrtest(mod3, mod2, nested=F) # non-nested models
library(survival)
library(nonnestcox)
pbc  <- subset(pbc, !is.na(trt))
mod1 <- coxph(Surv(time, status==2) ~ age, data=pbc, x=T)
mod2 <- coxph(Surv(time, status==2) ~ age + albumin + bili + edema + protime, data=pbc,  x=T)
mod3 <- coxph(Surv(time, status==2) ~ age + log(albumin) + log(bili) + edema + log(protime), data=pbc, x=T)
mod4<-  coxph(Surv(time, status==2) ~ albumin, data=pbc, x=T)
plrtest(mod3, mod2, nested=F) # non-nested models
plrtest(mod1, mod4, nested=F) # non-nested models
plrtest(mod3, mod2, nested=F) # non-nested models
plrtest(mod1, mod4, nested=F) # non-nested models
mod4<-  coxph(Surv(time, status==2) ~ bili, data=pbc, x=T)
plrtest(mod1, mod4, nested=F) # non-nested models
mod4<-  coxph(Surv(time, status==2) ~ log(albumin), data=pbc, x=T)
plrtest(mod1, mod4, nested=F) # non-nested models
citation("nonnestcox")
require("ababa")
?require
#function to install libraries
f_libraries<- function(){
#cran packages
cran.packages<- c("openxlsx",
"plyr",
"ggplot2",
"ggpubr",
"patchwork",
"survival",
"survminer")
for(aux.pack in cran.packages){
if(!require(aux.pack, character.only = TRUE)) install.packages(aux.pack)
library(aux.pack,character.only = TRUE)
}
rm(aux.pack)
#bioconductor packages
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
bioc.packages<- c("AnnotationDbi",
"org.Hs.eg.db",
"limma",
"BiocParallel")
for(aux.pack in bioc.packages){
if(!require(aux.pack, character.only = TRUE)){
BiocManager::install(bioc.packages)
}
library(aux.pack,character.only = TRUE)
}
rm(aux.pack)
#pbcmc package
if(!require(aux.pack, character.only = TRUE)){
source("http://bioconductor.org/biocLite.R")
biocLite("pbcmc")
}
message<- "All libraries seem to be present, properly loaded and installed"
return(message)
}
#function to check if installation was successful
f_check_libraries<- function(){
tryCatch({
f_libraries
}, error = function(e) {
"There was an error when installing or loading libraries, please manually check if they are all properly installed"
})
}
#function to install libraries
f_libraries<- function(){
#cran packages
cran.packages<- c("openxlsx",
"plyr",
"ggplot2",
"ggpubr",
"patchwork",
"survival",
"survminer")
for(aux.pack in cran.packages){
if(!require(aux.pack, character.only = TRUE)) install.packages(aux.pack)
library(aux.pack,character.only = TRUE)
}
rm(aux.pack)
#bioconductor packages
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
bioc.packages<- c("AnnotationDbi",
"org.Hs.eg.db",
"limma",
"BiocParallel")
for(aux.pack in bioc.packages){
if(!require(aux.pack, character.only = TRUE)){
BiocManager::install(bioc.packages)
}
library(aux.pack,character.only = TRUE)
}
rm(aux.pack)
#pbcmc package
if(!require(aux.pack, character.only = TRUE)){
source("http://bioconductor.org/biocLite.R")
biocLite("pbcmc")
}
message<- "All libraries seem to be present, properly loaded and installed"
return(message)
}
#function to check if installation was successful
f_check_libraries<- function(){
tryCatch({
f_libraries
}, error = function(e) {
"There was an error when installing or loading libraries, please manually check if they are all properly installed"
})
}
shiny::runApp('pancancer pam50/app/shinyapp')
runApp('pancancer pam50/app/shinyapp')
runApp('pancancer pam50/app/shinyapp')
runApp('pancancer pam50/app/shinyapp')
runApp('pancancer pam50/app/shinyapp')
runApp('pancancer pam50/app/shinyapp')
runApp('pancancer pam50/app/shinyapp')
runApp('pancancer pam50/app/shinyapp')
runApp('pancancer pam50/app/shinyapp')
f_check_libraries()
f_check_libraries
z<- f_check_libraries
z<- f_check_libraries()
z<- f_check_libraries(a)
#function to install libraries
f_libraries<- function(aux){
#cran packages
cran.packages<- c("openxlsx",
"plyr",
"ggplot2",
"ggpubr",
"patchwork",
"survival",
"survminer")
for(aux.pack in cran.packages){
if(!require(aux.pack, character.only = TRUE)) install.packages(aux.pack)
library(aux.pack,character.only = TRUE)
}
rm(aux.pack)
#bioconductor packages
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
bioc.packages<- c("AnnotationDbi",
"org.Hs.eg.db",
"limma",
"BiocParallel")
for(aux.pack in bioc.packages){
if(!require(aux.pack, character.only = TRUE)){
BiocManager::install(bioc.packages)
}
library(aux.pack,character.only = TRUE)
}
rm(aux.pack)
#pbcmc package
if(!require(aux.pack, character.only = TRUE)){
source("http://bioconductor.org/biocLite.R")
biocLite("pbcmc")
}
message<- "All libraries seem to be present, properly loaded and installed"
return(message)
}
#function to check if installation was successful
f_check_libraries<- function(aux){
message<- tryCatch({
f_libraries
}, error = function(e) {
"There was an error when installing or loading libraries, please manually check if they are all properly installed"
})
return(message)
}
z<- f_check_libraries()
z<- f_check_libraries(aux = NULL)
#function to install libraries
f_libraries<- function(){
#cran packages
cran.packages<- c("openxlsx",
"plyr",
"ggplot2",
"ggpubr",
"patchwork",
"survival",
"survminer")
for(aux.pack in cran.packages){
if(!require(aux.pack, character.only = TRUE)) install.packages(aux.pack)
library(aux.pack,character.only = TRUE)
}
rm(aux.pack)
#bioconductor packages
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
bioc.packages<- c("AnnotationDbi",
"org.Hs.eg.db",
"limma",
"BiocParallel")
for(aux.pack in bioc.packages){
if(!require(aux.pack, character.only = TRUE)){
BiocManager::install(bioc.packages)
}
library(aux.pack,character.only = TRUE)
}
rm(aux.pack)
#pbcmc package
if(!require(aux.pack, character.only = TRUE)){
source("http://bioconductor.org/biocLite.R")
biocLite("pbcmc")
}
message<- "All libraries seem to be present, properly loaded and installed"
return(message)
}
#function to check if installation was successful
f_check_libraries<- function(){
message<- tryCatch({
f_libraries()
}, error = function(e) {
"There was an error when installing or loading libraries, please manually check if they are all properly installed"
})
return(message)
}
z<- f_check_libraries()
z
f_libraries()
#cran packages
cran.packages<- c("openxlsx",
"plyr",
"ggplot2",
"ggpubr",
"patchwork",
"survival",
"survminer")
for(aux.pack in cran.packages){
if(!require(aux.pack, character.only = TRUE)) install.packages(aux.pack)
library(aux.pack,character.only = TRUE)
}
rm(aux.pack)
!require("pbcmc", character.only = TRUE)
aux.pack<- "AnnotationDbi"
!require(aux.pack, character.only = TRUE)
!require("pbcmc", character.only = TRUE)
runApp('pancancer pam50/app/shinyapp')
shiny::runApp('pancancer pam50/app/shinyapp')
runApp('pancancer pam50/app/shinyapp')
runApp('pancancer pam50/app/shinyapp')
runApp('pancancer pam50/app/shinyapp')
shiny::runApp('D:/github/tumor.agnostic/shinyapp')
runApp('D:/github/tumor.agnostic/shinyapp')
runApp('D:/github/tumor.agnostic/shinyapp')
exp<- read.xlsx("D:/proyectos/pancancer pam50/app/data/small_example.xlsx")
genes<- a.pam50$EntrezGene.ID
genes2<- do.call(c, a.signatures)
genes<- c(genes, genes2)
genes<- as.character(genes)
a.elist<- a.elist[as.character(genes),]
row.names(a.elist)<- a.elist$genes$entrezid
sum(! (genes %in% row.names(a.elist)) )
genes<- intersect(genes, row.names(a.elist))
genes<- a.pam50$EntrezGene.ID
setwd("D:/github/tumor.agnostic/shinyapp")
#a.signatures----
a.signatures<- list("proliferation"= read.table("data/proliferation.txt")$V1,
"ca20"= read.table("data/ca20.txt")$V1,
"rb"= read.table("data/rb.txt")$V1,
"tp53"= read.table("data/tp53.txt")$V1,
"differentiation"= read.table("data/differentiation.txt")$V1,
"core_95"= read.table("data/95_core.txt")$V1)
a.pam50<- read.xlsx("data/pam50.xlsx")
genes<- a.pam50$EntrezGene.ID
genes2<- do.call(c, a.signatures)
genes<- c(genes, genes2)
genes<- as.character(genes)
a.elist<- a.elist[as.character(genes),]
a.exp<- exp
#a.annot----
a.annot<- as.character(a.exp[,1])
a.annot<- f_annot_act(a.annot)
#A)DATA----
f_annot_act<- function(symbol.vec){
entrezids1 <- mapIds(org.Hs.eg.db, keys=symbol.vec, column="ENTREZID", keytype="SYMBOL", multiVals="first")
entrezids2<- mapIds(org.Hs.eg.db, keys=symbol.vec, column="ENTREZID", keytype="ALIAS", multiVals="first")
entrez<- ifelse(is.na(entrezids1), entrezids2, entrezids1)
entrez[sapply(entrez, is.null)]<- NA
entrez<- unlist(entrez)
return(entrez)
}
#a.load----
a.pam50<- read.xlsx("data/pam50.xlsx")
a.surv<- NULL
#check if surv data was provided
a.surv.provided<- ifelse(!is.null(a.surv), TRUE, FALSE)
#if surv was not loaded, create fake object
if(is.null(a.surv)){
a.surv<- data.frame("identifier"= colnames(a.exp)[-1],
stringsAsFactors = FALSE)
}
#if custom marker was provided, create indicator
a.custom.marker<- "custom_marker" %in% colnames(a.surv)
#a.annot----
a.annot<- as.character(a.exp[,1])
#if symbols were provided, convert to entrez
if(a.annot.is.symbol){
a.annot<- f_annot_act(a.annot)
}
a.annot.is.symbol<- TRUE
#if symbols were provided, convert to entrez
if(a.annot.is.symbol){
a.annot<- f_annot_act(a.annot)
}
#a.elist----
a.expression<- as.matrix(a.exp[,-1])
storage.mode(a.expression) <- "numeric"
a.elist<- new("EList", list(E= a.expression,
targets= a.surv,
genes= data.frame("entrezid"= a.annot,
"dummy"= NA,
stringsAsFactors=FALSE)))
#remove rows with missing annotation
a.elist<- a.elist[!is.na(a.elist$genes$entrezid),]
#a.avereps----
a.elist<- avereps(a.elist, ID = a.elist$genes$entrezid)
genes<- a.pam50$EntrezGene.ID
genes2<- do.call(c, a.signatures)
genes<- c(genes, genes2)
genes<- as.character(genes)
b.elist<- a.elist[as.character(genes),]
genes<- intersect(genes, row.names(b.elist))
genes<- intersect(genes, row.names(a.elist))
genes<- a.pam50$EntrezGene.ID
genes2<- do.call(c, a.signatures)
genes<- c(genes, genes2)
genes<- as.character(genes)
genes<- unique(genes)
genes<- intersect(genes, row.names(a.elist))
b.elist<- a.elist[as.character(genes),]
newgenes<- mapIds(org.Hs.eg.db, keys = row.names(a.elist$E), column = "SYMBOL", keytype = "ENTREZID")
dim(b.elist)
newexp<- b.elist$E
newexp<- cbind(newgenes, b.elist$E)
dim(b.elist)
newgenes<- mapIds(org.Hs.eg.db, keys = row.names(b.elist$E), column = "SYMBOL", keytype = "ENTREZID")
dim(b.elist)
newexp<- b.elist$E
newexp<- cbind(newgenes, b.elist$E)
dim(b.elist)
write.xlsx(newexp, "example_expression.xlsx")
getwd()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()

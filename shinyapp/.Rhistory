targets$pam50[targets$pam50=="Her2"]<- "Her2e"
#create targets
targets<- data.frame("pam50"= permutatedobject@permutation$subtype$PAM50,
"class"= permutatedobject@permutation$subtype$Class,
stringsAsFactors = FALSE)
str(targets)
#create targets
targets<- data.frame("pam50"= as.character(permutatedobject@permutation$subtype$PAM50),
"class"= as.character(permutatedobject@permutation$subtype$Class),
stringsAsFactors = FALSE)
#format targets
targets$class[targets$class == "LumA"]<- "C1"
targets$class[which(targets$class %in% c("Basal", "Her2", "LumB"))]<- "C2"
targets$class[targets$class == "Normal"]<- "unassigned"
targets$class[is.na(targets$class)]<- "unassigned"
targets$pam50[targets$pam50=="Her2"]<- "Her2e"
View(targets)
#C)CLASSIFY AND ANALYZE----
#function to generate the classification
#returns targets
f_classify<- function(exp.data){
#create pbcmc formatted annotation
pbcmc.annot<- data.frame("probe"= rownames(exp.data),
"EntrezGene.ID"= rownames(exp.data),
"NCBI.gene.symbol"= NA,
stringsAsFactors = FALSE)
row.names(pbcmc.annot)<- pbcmc.annot$probe
#apply pbcmc
pam50object<- PAM50(exprs = exp.data, annotation = pbcmc.annot)
filtratedobject<- filtrate(pam50object)
classifiedobject<- classify(filtratedobject, std = "median")
permutatedobject<- permutate(classifiedobject, nPerm=100, pCutoff=0.01, where="fdr",
corCutoff=0.1, keep=FALSE, verbose=TRUE,
BPPARAM=bpparam())
#create targets
targets<- data.frame("pam50"= as.character(permutatedobject@permutation$subtype$PAM50),
"class"= as.character(permutatedobject@permutation$subtype$Class),
stringsAsFactors = FALSE)
#format targets
targets$class[targets$class == "LumA"]<- "C1"
targets$class[which(targets$class %in% c("Basal", "Her2", "LumB"))]<- "C2"
targets$class[targets$class == "Normal"]<- "unassigned"
targets$class[is.na(targets$class)]<- "unassigned"
targets$pam50[targets$pam50=="Her2"]<- "Her2e"
return(targets)
}
b.classified<- f_classify(b.exp$exp)
#classification summary
f_class_sum<- function(class.vector){
#counts and props
counts<-  c("C1"= sum(class.vector$class == "C1"),
"C2"= sum(class.vector$class == "C2"),
"Unassigned"= sum(class.vector$class == "unassigned"))
props<- counts/length(class.vector)
#make table
table.content<- paste(counts, " (", props, "%)")
names(table.content)<- c("C1", "C2", "Unassigned")
return(table.content)
}
f_class_sum(targets$class)
#classification summary
f_class_sum<- function(class.vector){
#counts and props
counts<-  c("C1"= sum(class.vector == "C1"),
"C2"= sum(class.vector == "C2"),
"Unassigned"= sum(class.vector == "unassigned"))
props<- counts/length(class.vector)
#make table
table.content<- paste(counts, " (", props, "%)")
names(table.content)<- c("C1", "C2", "Unassigned")
return(table.content)
}
f_class_sum(targets$class)
#classification summary
f_class_sum<- function(class.vector){
#counts and props
counts<-  c("C1"= sum(class.vector == "C1"),
"C2"= sum(class.vector == "C2"),
"Unassigned"= sum(class.vector == "unassigned"))
props<- round(counts/length(class.vector), 2)
#make table
table.content<- paste0(counts, " (", props, "%)")
names(table.content)<- c("C1", "C2", "Unassigned")
return(table.content)
}
f_class_sum(targets$class)
#classification summary
f_class_sum<- function(class.vector){
#counts and props
counts<-  c("C1"= sum(class.vector == "C1"),
"C2"= sum(class.vector == "C2"),
"Unassigned"= sum(class.vector == "unassigned"))
props<- 100* round(counts/length(class.vector), 2)
#make table
table.content<- paste0(counts, " (", props, "%)")
names(table.content)<- c("C1", "C2", "Unassigned")
return(table.content)
}
f_class_sum(targets$class)
#classification summary
f_class_sum<- function(class.vector){
#counts and props
counts<-  c("C1"= sum(class.vector == "C1"),
"C2"= sum(class.vector == "C2"),
"Unassigned"= sum(class.vector == "unassigned"))
props<- round(100* counts/length(class.vector), 2)
#make table
table.content<- paste0(counts, " (", props, "%)")
names(table.content)<- c("C1", "C2", "Unassigned")
return(table.content)
}
f_class_sum(targets$class)
View(targets)
?join_all
#expression has rownames as entrezid
#expression columns match target identifiers
#targets has colnames identifier and class
#signatures is a list of character vectors with entrezid
#CA20 is one of the signatures
f_sigscore_wrap<- function(expression.data, targets.data, signature.list){
#select classified only
aux.index<- which(targets.data$class %in% c("C1", "C2"))
aux.exp<- expression.data[, aux.index]
#calculate generic sigscores
scores.list<- lapply(signature.list, function(one.signature){
f_sigscores(aux.sig = one.signature, aux.cancer = aux.exp)
})
#calculate CA20 separately
scores.list$CA20<- f_sigscores_ca20(aux.sig = signature.list$CA20, aux.cancer = aux.exp)
#rename columns
for(aux.name in names(scores.list)){
colnames(scores.list[[aux.name]][2])<- aux.name
}
#combine with targets
new.targets<- join_all(scores.list, by="identifier", type="full")
return(new.targets)
}
#D)SIGNATURES----
f_sigscores_ca20<- function(aux.sig, aux.cancer){
#centrar y escalar la base
aux.expr<- aux.cancer$E-median(aux.cancer$E, na.rm=TRUE)
aux.expr<- aux.expr/sd(aux.expr, na.rm=TRUE)
#recortar genes
row.names(aux.expr)<- aux.cancer$genes$entrezid
aux.genes<- intersect(row.names(aux.expr), aux.sig)
aux.expr<- aux.expr[aux.genes,]
#calcular los scores por suma
aux.scores<- colSums(aux.expr, na.rm=TRUE)
summary(aux.scores)
#objeto salida
aux.salida<- data.frame("identifier"= colnames(aux.cancer$E),
"sigscore"= aux.scores, stringsAsFactors = FALSE)
return(aux.salida)
}
f_sigscores<- function(aux.sig, aux.cancer){
#extraer expresiÃ³n
aux.expr<- aux.cancer$E
#recortar genes
row.names(aux.expr)<- aux.cancer$genes$entrezid
aux.genes<- intersect(row.names(aux.expr), aux.sig)
aux.expr<- aux.expr[aux.genes,]
#estandarizar genes
aux.expr<- t(scale(t(aux.expr)))
#calcular score por promedio
aux.scores<- colMeans(aux.expr, na.rm=TRUE)
#objeto salida
aux.salida<- data.frame("identifier"= colnames(aux.cancer$E),
"sigscore"= aux.scores, stringsAsFactors = FALSE)
return(aux.salida)
}
b.classified<- f_classify(b.exp$exp)
#C)CLASSIFY AND ANALYZE----
#function to generate the classification
#returns targets
f_classify<- function(exp.data){
#create pbcmc formatted annotation
pbcmc.annot<- data.frame("probe"= rownames(exp.data),
"EntrezGene.ID"= rownames(exp.data),
"NCBI.gene.symbol"= NA,
stringsAsFactors = FALSE)
row.names(pbcmc.annot)<- pbcmc.annot$probe
#apply pbcmc
pam50object<- PAM50(exprs = exp.data, annotation = pbcmc.annot)
filtratedobject<- filtrate(pam50object)
classifiedobject<- classify(filtratedobject, std = "median")
permutatedobject<- permutate(classifiedobject, nPerm=100, pCutoff=0.01, where="fdr",
corCutoff=0.1, keep=FALSE, verbose=TRUE,
BPPARAM=bpparam())
#create targets
targets<- data.frame("identifier"= colnames(exp.data),
"pam50"= as.character(permutatedobject@permutation$subtype$PAM50),
"class"= as.character(permutatedobject@permutation$subtype$Class),
stringsAsFactors = FALSE)
#format targets
targets$class[targets$class == "LumA"]<- "C1"
targets$class[which(targets$class %in% c("Basal", "Her2", "LumB"))]<- "C2"
targets$class[targets$class == "Normal"]<- "unassigned"
targets$class[is.na(targets$class)]<- "unassigned"
targets$pam50[targets$pam50=="Her2"]<- "Her2e"
return(targets)
}
b.classified<- f_classify(b.exp$exp)
c.newtargets<- f_sigscore_wrap(expression.data = b.exp$exp,
targets.data = b.classified,
signature.list = a.signatures)
#D)SIGNATURES----
f_sigscores_ca20<- function(gene.vector, expression.matrix){
#centrar y escalar la base
aux.expr<- expression.matrix-median(expression.matrix, na.rm=TRUE)
aux.expr<- aux.expr/sd(aux.expr, na.rm=TRUE)
#recortar genes
aux.genes<- intersect(row.names(aux.expr), gene.vector)
aux.expr<- aux.expr[aux.genes,]
#calcular los scores por suma
aux.scores<- colSums(aux.expr, na.rm=TRUE)
summary(aux.scores)
#objeto salida
aux.salida<- data.frame("identifier"= colnames(aux.cancer$E),
"sigscore"= aux.scores, stringsAsFactors = FALSE)
return(aux.salida)
}
?colMeans
f_sigscores<- function(gene.vector, expression.matrix){
#recortar genes
aux.genes<- intersect(row.names(expression.matrix), gene.vector)
aux.expr<- expression.matrix[aux.genes,]
#estandarizar genes
aux.expr<- t(scale(t(aux.expr)))
#calcular score por promedio
aux.scores<- colMeans(aux.expr, na.rm=TRUE)
#objeto salida
aux.salida<- data.frame("identifier"= colnames(aux.cancer$E),
"sigscore"= aux.scores, stringsAsFactors = FALSE)
return(aux.salida)
}
c.newtargets<- f_sigscore_wrap(expression.data = b.exp$exp,
targets.data = b.classified,
signature.list = a.signatures)
#expression has rownames as entrezid
#expression columns match target identifiers
#targets has colnames identifier and class
#signatures is a list of character vectors with entrezid
#CA20 is one of the signatures
f_sigscore_wrap<- function(expression.data, targets.data, signature.list){
#select classified only
aux.index<- which(targets.data$class %in% c("C1", "C2"))
aux.exp<- expression.data[, aux.index]
#calculate generic sigscores
scores.list<- lapply(signature.list, function(one.signature){
f_sigscores(gene.vector = one.signature, expression.matrix = aux.exp)
})
#calculate CA20 separately
scores.list$CA20<- f_sigscores_ca20(gene.vector = signature.list$CA20, expression.matrix = aux.exp)
#rename columns
for(aux.name in names(scores.list)){
colnames(scores.list[[aux.name]][2])<- aux.name
}
#combine with targets
new.targets<- join_all(scores.list, by="identifier", type="full")
return(new.targets)
}
c.newtargets<- f_sigscore_wrap(expression.data = b.exp$exp,
targets.data = b.classified,
signature.list = a.signatures)
#D)SIGNATURES----
f_sigscores_ca20<- function(gene.vector, expression.matrix){
#centrar y escalar la base
aux.expr<- expression.matrix-median(expression.matrix, na.rm=TRUE)
aux.expr<- aux.expr/sd(aux.expr, na.rm=TRUE)
#recortar genes
aux.genes<- as.character(intersect(row.names(aux.expr), gene.vector))
aux.expr<- aux.expr[aux.genes,]
#calcular los scores por suma
aux.scores<- colSums(aux.expr, na.rm=TRUE)
summary(aux.scores)
#objeto salida
aux.salida<- data.frame("identifier"= colnames(aux.cancer$E),
"sigscore"= aux.scores, stringsAsFactors = FALSE)
return(aux.salida)
}
f_sigscores<- function(gene.vector, expression.matrix){
#recortar genes
aux.genes<- as.character(intersect(row.names(expression.matrix), gene.vector))
aux.expr<- expression.matrix[aux.genes,]
#estandarizar genes
aux.expr<- t(scale(t(aux.expr)))
#calcular score por promedio
aux.scores<- colMeans(aux.expr, na.rm=TRUE)
#objeto salida
aux.salida<- data.frame("identifier"= colnames(aux.cancer$E),
"sigscore"= aux.scores, stringsAsFactors = FALSE)
return(aux.salida)
}
#expression has rownames as entrezid
#expression columns match target identifiers
#targets has colnames identifier and class
#signatures is a list of character vectors with entrezid
#CA20 is one of the signatures
f_sigscore_wrap<- function(expression.data, targets.data, signature.list){
#select classified only
aux.index<- which(targets.data$class %in% c("C1", "C2"))
aux.exp<- expression.data[, aux.index]
#calculate generic sigscores
scores.list<- lapply(signature.list, function(one.signature){
f_sigscores(gene.vector = one.signature, expression.matrix = aux.exp)
})
#calculate CA20 separately
scores.list$CA20<- f_sigscores_ca20(gene.vector = signature.list$CA20, expression.matrix = aux.exp)
#rename columns
for(aux.name in names(scores.list)){
colnames(scores.list[[aux.name]][2])<- aux.name
}
#combine with targets
new.targets<- join_all(scores.list, by="identifier", type="full")
return(new.targets)
}
c.newtargets<- f_sigscore_wrap(expression.data = b.exp$exp,
targets.data = b.classified,
signature.list = a.signatures)
c.newtargets<- f_sigscore_wrap(expression.data = b.exp$exp,
targets.data = b.classified,
signature.list = a.signatures)
#D)SIGNATURES----
f_sigscores_ca20<- function(gene.vector, expression.matrix){
#centrar y escalar la base
aux.expr<- expression.matrix-median(expression.matrix, na.rm=TRUE)
aux.expr<- aux.expr/sd(aux.expr, na.rm=TRUE)
#recortar genes
aux.genes<- as.character(intersect(row.names(aux.expr), gene.vector))
aux.expr<- aux.expr[aux.genes,]
#calcular los scores por suma
aux.scores<- colSums(aux.expr, na.rm=TRUE)
summary(aux.scores)
#objeto salida
aux.salida<- data.frame("identifier"= colnames(expression.matrix),
"sigscore"= aux.scores, stringsAsFactors = FALSE)
return(aux.salida)
}
f_sigscores<- function(gene.vector, expression.matrix){
#recortar genes
aux.genes<- as.character(intersect(row.names(expression.matrix), gene.vector))
aux.expr<- expression.matrix[aux.genes,]
#estandarizar genes
aux.expr<- t(scale(t(aux.expr)))
#calcular score por promedio
aux.scores<- colMeans(aux.expr, na.rm=TRUE)
#objeto salida
aux.salida<- data.frame("identifier"= colnames(expression.matrix),
"sigscore"= aux.scores, stringsAsFactors = FALSE)
return(aux.salida)
}
#expression has rownames as entrezid
#expression columns match target identifiers
#targets has colnames identifier and class
#signatures is a list of character vectors with entrezid
#CA20 is one of the signatures
f_sigscore_wrap<- function(expression.data, targets.data, signature.list){
#select classified only
aux.index<- which(targets.data$class %in% c("C1", "C2"))
aux.exp<- expression.data[, aux.index]
#calculate generic sigscores
scores.list<- lapply(signature.list, function(one.signature){
f_sigscores(gene.vector = one.signature, expression.matrix = aux.exp)
})
#calculate CA20 separately
scores.list$CA20<- f_sigscores_ca20(gene.vector = signature.list$CA20, expression.matrix = aux.exp)
#rename columns
for(aux.name in names(scores.list)){
colnames(scores.list[[aux.name]][2])<- aux.name
}
#combine with targets
new.targets<- join_all(scores.list, by="identifier", type="full")
return(new.targets)
}
c.newtargets<- f_sigscore_wrap(expression.data = b.exp$exp,
targets.data = b.classified,
signature.list = a.signatures)
library(plyr)
#expression has rownames as entrezid
#expression columns match target identifiers
#targets has colnames identifier and class
#signatures is a list of character vectors with entrezid
#CA20 is one of the signatures
f_sigscore_wrap<- function(expression.data, targets.data, signature.list){
#select classified only
aux.index<- which(targets.data$class %in% c("C1", "C2"))
aux.exp<- expression.data[, aux.index]
#calculate generic sigscores
scores.list<- lapply(signature.list, function(one.signature){
f_sigscores(gene.vector = one.signature, expression.matrix = aux.exp)
})
#calculate CA20 separately
scores.list$CA20<- f_sigscores_ca20(gene.vector = signature.list$CA20, expression.matrix = aux.exp)
#rename columns
for(aux.name in names(scores.list)){
colnames(scores.list[[aux.name]][2])<- aux.name
}
#combine with targets
new.targets<- plyr::join_all(scores.list, by="identifier", type="full")
return(new.targets)
}
c.newtargets<- f_sigscore_wrap(expression.data = b.exp$exp,
targets.data = b.classified,
signature.list = a.signatures)
View(c.newtargets)
#expression has rownames as entrezid
#expression columns match target identifiers
#targets has colnames identifier and class
#signatures is a list of character vectors with entrezid
#CA20 is one of the signatures
f_sigscore_wrap<- function(expression.data, targets.data, signature.list){
#select classified only
aux.index<- which(targets.data$class %in% c("C1", "C2"))
aux.exp<- expression.data[, aux.index]
#calculate generic sigscores
scores.list<- lapply(signature.list, function(one.signature){
f_sigscores(gene.vector = one.signature, expression.matrix = aux.exp)
})
#calculate CA20 separately
scores.list$CA20<- f_sigscores_ca20(gene.vector = signature.list$CA20, expression.matrix = aux.exp)
#rename columns
for(aux.name in names(scores.list)){
colnames(scores.list[[aux.name]])[2]<- aux.name
}
#combine with targets
new.targets<- plyr::join_all(scores.list, by="identifier", type="full")
new.targets<- join(targets.data, new.targets, by="identifier", type="full")
return(new.targets)
}
c.newtargets<- f_sigscore_wrap(expression.data = b.exp$exp,
targets.data = b.classified,
signature.list = a.signatures)
View(c.newtargets)
#E)PLOTS----
f_plot<- function(sig.name, targets.table){
error.plot<- ggplot() +
annotate(geom = 'text',
x=1,
y=1,
label= paste0("Could not analyze ", sig.name, "\nmaybe there are insufficient classified samples"),
size = 4) +
theme_void()
el.plot<- tryCatch({
ggboxplot(targets.table, x = "class", y = sig.name,
color = "class",
palette = c("C1"="#005397", "C2"="#E58031"),
add = "jitter") +
stat_compare_means(method = "wilcox.test")
} error = function(e){
error.plot
})
return(el.plot)
}
#E)PLOTS----
f_plot<- function(sig.name, targets.table){
error.plot<- ggplot() +
annotate(geom = 'text',
x=1,
y=1,
label= paste0("Could not analyze ", sig.name, "\nmaybe there are insufficient classified samples"),
size = 4) +
theme_void()
el.plot<- tryCatch({
ggboxplot(targets.table, x = "class", y = sig.name,
color = "class",
palette = c("C1"="#005397", "C2"="#E58031"),
add = "jitter") + stat_compare_means(method = "wilcox.test")
} error = function(e){
error.plot
})
return(el.plot)
}
#E)PLOTS----
f_plot<- function(sig.name, targets.table){
error.plot<- ggplot() +
annotate(geom = 'text',
x=1,
y=1,
label= paste0("Could not analyze ", sig.name, "\nmaybe there are insufficient classified samples"),
size = 4) +
theme_void()
el.plot<- tryCatch({
ggboxplot(targets.table, x = "class", y = sig.name,
color = "class",
palette = c("C1"="#005397", "C2"="#E58031"),
add = "jitter") + stat_compare_means(method = "wilcox.test")
}, error = function(e){
error.plot
})
return(el.plot)
}
f_plot_wrap<- function(sig.list, targets){
signames<- intersect(names(sig.list), colnames(targets))
plotlist<- lapply(signames, function(one.sig){
f_plot(sig.name = one.sig, targets.table = targets)
})
plotfin<- wrap_plots(plotlist, ncol=3)
return(plotfin)
}
e.plots<- f_plot_wrap(sig.list = a.signatures, targets = c.newtargets)
e.plots
f_plot_wrap<- function(sig.list, targets){
this.targets<- targets[which(targets$class %in% c("C1", "C2")),]
signames<- intersect(names(sig.list), colnames(this.targets))
plotlist<- lapply(signames, function(one.sig){
f_plot(sig.name = one.sig, targets.table = this.targets)
})
plotfin<- wrap_plots(plotlist, ncol=3)
return(plotfin)
}
e.plots<- f_plot_wrap(sig.list = a.signatures, targets = c.newtargets)
e.plots
